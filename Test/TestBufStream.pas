unit TestBufStream;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, CustomTestCase, System.SysUtils, System.Classes, BufStream;

type
  // Test methods for class BufferedStream

  TestBufferedStreamBase = class(TCustomTestCase)
  strict private
    FBufferedStream: BufferedStream;
  protected
    procedure CreateTestStream(const BufferSize: integer);
    function SourceStreamData: TBytes;
  public
    procedure TearDown; override;
  published
    procedure TestReadSingleByte;
    procedure TestReadAllSingle;
    procedure TestWrite;
    procedure TestSeek;
    procedure TestFillBuffer;
    procedure TestConsumeBufferSingleByte;
    procedure TestConsumeBufferFullBuffer;
    procedure TestConsumeBufferAll;
    procedure TestDiscardBuffer;
  end;

  TestBufferedStreamSmallBuffer = class(TestBufferedStreamBase)
  public
    procedure SetUp; override;
  end;

  TestBufferedStreamLargeBuffer = class(TestBufferedStreamBase)
  public
    procedure SetUp; override;
  end;

implementation

procedure TestBufferedStreamBase.CreateTestStream(const BufferSize: integer);
var
  data: TBytes;
  bs: TBytesStream;
begin
  data := TEncoding.ASCII.GetBytes('abcdef');
  bs := TBytesStream.Create(data);
  FBufferedStream := BufferedStream.Create(bs, [BufferedStreamOwnsSource], BufferSize);
end;

function TestBufferedStreamBase.SourceStreamData: TBytes;
begin
  result := (FBufferedStream.SourceStream as TBytesStream).Bytes;
end;

procedure TestBufferedStreamBase.TearDown;
begin
  FBufferedStream.Free;
  FBufferedStream := nil;
end;

procedure TestBufferedStreamBase.TestWrite;
var
  ReturnValue: System.Integer;
  Count: System.Integer;
  Buffer: TBytes;
begin
  Buffer := TEncoding.ASCII.GetBytes('12345');
  Count := Length(Buffer);

  StartExpectingException(ENotSupportedException);

  ReturnValue := FBufferedStream.Write(Buffer, Count);

  StopExpectingException('Write implemented, remove this check!');

  CheckEquals(Count, ReturnValue, 'Write failed');

  CheckEquals(11, Length(SourceStreamData), 'Write failed to propagate data correctly to source');

  CheckEqualsMem(@Buffer[0], @SourceStreamData[6], Count, 'Write wrote bad data');
end;

procedure TestBufferedStreamBase.TestSeek;
var
  ReturnValue: Int64;
  Origin: TSeekOrigin;
  Offset: Int64;
begin
  FBufferedStream.FillBuffer;
  Origin := soBeginning;
  Offset := 1;
  ReturnValue := FBufferedStream.Seek(Offset, Origin);

  CheckEquals(1, ReturnValue, 'Seek from beginning failed');
  CheckEquals(ReturnValue, FBufferedStream.Position, 'Position wrong after Seek from beginning');
  CheckNull(FBufferedStream.BufferedData, 'Seek from beginning failed to clear buffer data');
  CheckEquals(0, FBufferedStream.BufferedDataLength, 'Seek from beginning failed to reset buffer length');


  // FillBuffer will increase source position
  FBufferedStream.FillBuffer;
  Origin := soCurrent;
  Offset := 2;
  ReturnValue := FBufferedStream.Seek(Offset, Origin);

  CheckEquals(3, ReturnValue, 'Seek from current with positive offset failed');
  CheckEquals(ReturnValue, FBufferedStream.Position, 'Position wrong after Seek from current with positive offset');
  CheckNull(FBufferedStream.BufferedData, 'Seek from current failed to clear buffer data');
  CheckEquals(0, FBufferedStream.BufferedDataLength, 'Seek from current failed to reset buffer length');


  // FillBuffer will increase source position
  FBufferedStream.FillBuffer;
  Origin := soCurrent;
  Offset := -1;
  ReturnValue := FBufferedStream.Seek(Offset, Origin);

  CheckEquals(2, ReturnValue, 'Seek from current with negative offset failed');
  CheckEquals(ReturnValue, FBufferedStream.Position, 'Position wrong after Seek from current with negative offset');
  CheckNull(FBufferedStream.BufferedData, 'Seek from current failed to clear buffer data');
  CheckEquals(0, FBufferedStream.BufferedDataLength, 'Seek from current failed to reset buffer length');


  FBufferedStream.FillBuffer;
  Origin := soEnd;
  Offset := -3;
  ReturnValue := FBufferedStream.Seek(Offset, Origin);

  CheckEquals(3, ReturnValue, 'Seek from end failed');
  CheckEquals(ReturnValue, FBufferedStream.Position, 'Position wrong after Seek from end');
  CheckNull(FBufferedStream.BufferedData, 'Seek from end failed to clear buffer data');
  CheckEquals(0, FBufferedStream.BufferedDataLength, 'Seek from end failed to reset buffer length');


  FBufferedStream.FillBuffer;
  Origin := soCurrent;
  Offset := 0;
  ReturnValue := FBufferedStream.Seek(Offset, Origin);

  CheckEquals(3, ReturnValue, 'Seek returned incorrect current position');
  CheckEquals(ReturnValue, FBufferedStream.Position, 'Position wrong after Seek from current with zero offset');
  CheckNotNull(FBufferedStream.BufferedData, 'Seek from current with zero offset cleared buffer data');
  CheckNotEquals(0, FBufferedStream.BufferedDataLength, 'Seek from current with zero offset reset buffer length');
end;


procedure TestBufferedStreamBase.TestFillBuffer;
var
  i: integer;
  ReturnValue: Boolean;
begin
  for i := 1 to 7 do
  begin
    CheckNotEquals(7, i, 'FillBuffer failed to exhaust source');

    ReturnValue := FBufferedStream.FillBuffer;

    CheckNotNull(FBufferedStream.BufferedData, 'FillBuffer failed to assign buffered data pointer');
    CheckTrue(FBufferedStream.BufferedDataLength <= 6, 'FillBuffer read too much data');

    if (FBufferedStream.BufferedDataLength = 6) then
    begin
      break;
    end;

    CheckTrue(ReturnValue, 'FillBuffer prematurely signaled end of source');
  end;

  ReturnValue := FBufferedStream.FillBuffer;
  CheckFalse(ReturnValue, 'FillBuffer did not signal end of source');
  CheckEquals(6, FBufferedStream.BufferedDataLength, 'FillBuffer read too much data');

  CheckEqualsMem(@SourceStreamData[0], FBufferedStream.BufferedData, 6, 'FillBuffer filled buffer with bad data');
end;

procedure TestBufferedStreamBase.TestReadAllSingle;
var
  ReturnValue: System.Integer;
  Count: System.Integer;
  Buffer: Byte;
  i: integer;
begin
  Count := 1;
  for i := 0 to 5 do
  begin
    Buffer := 0;

    ReturnValue := FBufferedStream.Read(Buffer, Count);

    CheckEquals(Count, ReturnValue, 'Read failed');

    CheckNotEquals(0, Buffer, 'Read didn''t fill buffer');

    CheckEquals(Ord('a') + i, Buffer, 'Read returned wrong data');
  end;
end;

procedure TestBufferedStreamBase.TestReadSingleByte;
var
  ReturnValue: System.Integer;
  Count: System.Integer;
  Buffer: Byte;
begin
  Count := 1;
  Buffer := 0;

  ReturnValue := FBufferedStream.Read(Buffer, Count);

  CheckEquals(Count, ReturnValue, 'Read failed');

  CheckNotEquals(0, Buffer, 'Read didn''t fill buffer');

  CheckEquals(Ord('a'), Buffer, 'Read returned wrong data');
end;

procedure TestBufferedStreamBase.TestConsumeBufferAll;
var
  Size: Integer;
begin
  while FBufferedStream.FillBuffer do;

  CheckEquals(6, FBufferedStream.BufferedDataLength, 'Failed to fill entire source in buffer');

  Size := 0;
  FBufferedStream.ConsumeBuffer(Size);
  CheckNotNull(FBufferedStream.BufferedData, 'ConsumeBuffer erroneously cleared buffer data (1st)');
  CheckEquals(6, FBufferedStream.BufferedDataLength, 'ConsumeBuffer consumed wrong amount (1st)');

  Size := 3;
  FBufferedStream.ConsumeBuffer(Size);
  CheckNotNull(FBufferedStream.BufferedData, 'ConsumeBuffer erroneously cleared buffer data (2nd)');
  CheckEquals(3, FBufferedStream.BufferedDataLength, 'ConsumeBuffer consumed wrong amount (2nd)');

  Size := 2;
  FBufferedStream.ConsumeBuffer(Size);
  CheckNotNull(FBufferedStream.BufferedData, 'ConsumeBuffer erroneously cleared buffer data (3rd)');
  CheckEquals(1, FBufferedStream.BufferedDataLength, 'ConsumeBuffer consumed wrong amount (3rd)');

  Size := 1;
  FBufferedStream.ConsumeBuffer(Size);
  CheckEquals(0, FBufferedStream.BufferedDataLength, 'ConsumeBuffer failed to exhaust buffer');
  CheckNull(FBufferedStream.BufferedData, 'ConsumeBuffer failed to reset buffer data pointer upon buffer exhaustion');
end;

procedure TestBufferedStreamBase.TestConsumeBufferFullBuffer;
var
  Size: Integer;
begin
  FBufferedStream.FillBuffer;
  Size := FBufferedStream.BufferedDataLength;

  FBufferedStream.ConsumeBuffer(Size);

  CheckEquals(0, FBufferedStream.BufferedDataLength, 'ConsumeBuffer failed to consume entire buffer');
end;

procedure TestBufferedStreamBase.TestConsumeBufferSingleByte;
var
  i, n: integer;
  Size: Integer;
begin
  FBufferedStream.FillBuffer;
  n := FBufferedStream.BufferedDataLength;

  for i := 1 to n-1 do
  begin
    Size := 1;
    FBufferedStream.ConsumeBuffer(Size);
    CheckNotNull(FBufferedStream.BufferedData, 'ConsumeBuffer erroneously cleared buffer data');
    CheckEquals(n-i, FBufferedStream.BufferedDataLength, 'ConsumeBuffer consumed wrong amount');
  end;

  Size := 1;
  FBufferedStream.ConsumeBuffer(Size);
  CheckEquals(0, FBufferedStream.BufferedDataLength, 'ConsumeBuffer failed to exhaust buffer');
  CheckNull(FBufferedStream.BufferedData, 'ConsumeBuffer failed to reset buffer data pointer upon buffer exhaustion');
end;

procedure TestBufferedStreamBase.TestDiscardBuffer;
begin
  FBufferedStream.FillBuffer;

  FBufferedStream.DiscardBuffer;

  CheckNull(FBufferedStream.BufferedData, 'DiscardBuffer failed to discard buffer data');
  CheckEquals(0, FBufferedStream.BufferedDataLength, 'DiscardBuffer failed to reset buffer data length');
end;

{ TestBufferedStreamSmallBuffer }

procedure TestBufferedStreamSmallBuffer.SetUp;
begin
  CreateTestStream(2);
end;

{ TestBufferedStreamLargeBuffer }

procedure TestBufferedStreamLargeBuffer.SetUp;
begin
  CreateTestStream(4096);
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestBufferedStreamSmallBuffer.Suite);
  RegisterTest(TestBufferedStreamLargeBuffer.Suite);
end.

